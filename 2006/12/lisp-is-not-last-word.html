<html> 
<head>
        
        <title>Lisp is not the last word</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />



	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

	<div id="leftcontent">
			<a href="http://raganwald.com/"><img src="/assets/media/raganwald_2008_350_150.png" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/></a><br/>(<i>This is a snapshot of my old weblog. New posts and selected republished essays can be found at <a href="http://raganwald.com"><strong>raganwald.com</strong></a></i>.)<br/><br/>
			
				<div class="DateHeader">Saturday, December 16, 2006</div>
			

			<div class="Post"><a name="116628208495215893">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html" title="permanent link">Lisp is not the last word</a></span>
					<div style="clear:both;"></div><br/><br/><a href="http://www.tilton-technology.com/">Ken Tilton</a> <a href="http://groups-beta.google.com/group/comp.lang.lisp/msg/c03b6b011661c011" title="comp.lang.lisp posting">asked</a>: <em>What is up the power continuum from Lisp?</em><br /><br />I don’t have a ready answer. However, just because I don’t have an answer doesn’t mean I don’t believe there’s an answer. It could be that Lisp is a little like Democracy. It could be the least powerful programming language possible, excepting all of the others invented so far. But you know what? I have faith <em>we can do better</em>.<br /><br />Ken doesn’t say there isn’t a language up the power continuum. And I won’t say we have already invented one: like Ken, I’ll pose a question: <em>what law of computer science places a limit on the power continuum at Lisp?</em><br /><br /><div style="margin: 0pt 0pt 10px 10px; width: 240px; float: right; text-align: center; font-size: 85%;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/1400077974?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=1400077974"><img style="" src="http://weblog.raganwald.com/uploaded_images/meta_math-757398.png" alt="" border="0" /></a><em><br /><br />G.J. Chaitin explains his proofs of Kurt Godel’s incompleteness theorem and Alan Turing’s “halting problem” in computation. Chaitin’s creative use of Lisp in mathematics and fervent belief that no theorem is proof against new analysis are welcome shots of espresso.</em></div>Human history is chock-a-block full of inventions and practices that were considered for decades or even centuries to be the final word, the ultimate expression and implementation of ideas. And then someone came along and demolished everything. Geocentricity. Heliocentricity. Newtonian celestial mechanics. Light as a wave. Light as a particle. Three dimensions. Uniform space. Euclidian geometry.<br /><br />Some of these new ideas took years to take root while the establishment derided them as “not even wrong.” Others were so obviously right they immediately displaced what had come before. We might now have invented a more powerful language. Or we might have invented one but not realize it yet. But who can say that we haven’t invented a more powerful language and will never do so?<br /><br />If you believe there <span style="font-style: italic;">is</span> a power continuum, if you are not so obsessed with Turing Completeness and theoretical equivalence, what is the argument that it has any limit whatsoever, let alone that its limit is Lisp?<br /><br />I believe that the only language that is affixed to the top of the power continuum is <a href="http://weblog.raganwald.com/2006/10/are-we-blub-programmers.html">Blub</a>. For everyone whose imagination soars above the ceiling of their laboratory, Lisp is not the last word.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://weblog.raganwald.com/labels/lispy.html">lispy</a>, <a rel='tag' href="http://weblog.raganwald.com/labels/popular.html">popular</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html" title="permanent link">9:56 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			
			    <div class="blogComments">
                                
                                <a name="comments"></a><strong>Comments on &ldquo;<em>Lisp is not the last word</em>&rdquo;</strong>:<br/>
						
							<div class="blogComment">
								<a name="116628525363260771"></a> 				This essay neglects to address the crux of the matter, which the author may not have realized was the other shoe waiting to drop when I asked that question: Lisp may not have powerful new feature X (such as the automatic dataflow management provided by my pure-CL Cells package), but once we have done the Turing thing and built a dataflow engine using standard lisp, we can hide all the wiring with macrology and special variables and symbol macros etc and make it look as if Lisp was a dataflow language. Something like continuations would be an example of something CL cannot really do, but then we get to argue over whether those are a Good Thing.  :)<BR/><BR/>In other words, I was not saying new ideas are not to be had, I was saying CL will probably be able to absorb them and provide them as if they were always part of the language, because CL is a meta-language, or as Foderaro said, a programmable programming language.<BR/><BR/>ken tilton<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166285220000#c116628525363260771" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 11:07 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116628525363260771" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116629008266355182"></a> 				I've read Graham's article several times over the years, and your post prompted me to examine it more deeply.<BR/><BR/>We always think of the article as him claiming that Lisp is the most powerful language (which I'll concede he does).  What I haven't realized until this morning though is that he really means that Lisp has the most powerful abstraction.  In fact, the first two times he mentions "continuum," he associates it with "abstraction" rather than "power":<BR/><BR/>"Languages fall along a continuum of abstractness"<BR/>"Blub falls right in the middle of the abstractness continuum."<BR/><BR/>Programs are collections of data and behavior, and the code is how we express it.  However Lisp treats code as data itself - the highest abstraction a language can make.<BR/><BR/>I think, anyway.  Is there a higher abstraction than a language treating its own code as data?  I don't think so.<BR/><BR/>He claims that languages may asymptotically approach Lisp, but if they implement all its key features than they're just another dialect of Lisp.  I think that's inaccurate.  Lisp is perhaps simply the sole member of another family of languages, which I'll tritely coin meta-oriented languages :)  There's nothing to stop another language from joining that family, and indeed some - such as Ruby - are quite close.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166290080000#c116629008266355182" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://evang.eli.st/blog/" rel="nofollow">Pat Maddox</a> : 12:28 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116629008266355182" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116629596788784477"></a> 				The very word "continuum" pleasingly reminds me of Cantor's infinities. Perhaps there is, as Pat suggests, a family of similar programmable programming languages with Lisp as the wise elder.<BR/><BR/>I agree that homoiconity is the highest abstraction we know how to make. However, I am not at all sure that Lisp's expression of homiconity is the most abstract or most powerful expression possible.<BR/><BR/>In all Lisps, the syntax of code is data. The symbols and data structures of the program. However, programs are far, far more than their notation.<BR/><BR/>For example, languages with continuations (obviously including Lisps like Scheme) include an abstraction of programs that is not just the program itself.<BR/><BR/>I expect that there are many other elements of programs that could be reified to produce more powerful members of the "programmable programming languages" family.<BR/><BR/>I agree with Ken that we can make Lisp look like a language with continuations or dataflow or anything else. But if we call such variations "Common Lisp" we dilute the meaning of the name. Such languages may be new members of the Lisp family, and they may be built on top of Common Lisp, but I think that arguing they <I>are</I> Common Lisp is a little like arguing Ruby is C.<BR/><BR/>In short I argue that the 'meta-language' character of Lisp doesn't make it the most powerful language on the continuum, just possibly the most convenient for building more powerful languages.<BR/><BR/>I've argued (in support of languages like Lisp and Ruby) that <A HREF="http://weblog.raganwald.com/2006/01/finding-signal-to-noise-ratio-in-never.html" REL="nofollow" TITLE="Finding the Signal-to-Noise Ratio in the Never-Ending Language Debate">the idiom for building idioms is itself an idiom</A>. Who is to say that we won't invent better idioms for programming programmable programming languages?<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166295960000#c116629596788784477" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 2:06 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116629596788784477" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116630391158280931"></a> 				Three quick thoughts, Reg:<BR/><BR/>1. "[A Blub programmer] doesn't realize he's looking up. What he sees are merely weird languages..."<BR/><BR/>Lisp programmers cannot be Blub programmers. To rephrase Tilton, what on Earth would a Lisp programmer think of as weird? I mean genuinely weird, not merely perverse like Befunge or Brainf*ck.<BR/><BR/>2. I reject the argument that "foo is part of CL because once you discover foo you can write it in CL". Being part of CL means you don't have to write it yourself in CL. New ideas must overcome existing idiom. This problem is orthogonal to the extensibility of a language.<BR/><BR/>3. Lisp is at the top of a continuum that is losing relevance daily because other dimensions outside that continuum are becoming more and more vital to the fitness of a language.<BR/><BR/>Learning Lisp is like climbing Mount Everest. Like Everest, once you get up there you can say, "I am at the highest point on the whole Earth!" But then you look around and realize that the only people up there with you are crazed hermits, enigmatic sherpas, and a lot of rich white tourists. Let's consider just the economic dimension here: the hermits are up there because they hate capitalism and have gone a bit funny. The sherpas are up there earning minimum wage because they love the mountain. And the rich white tourists? They're up there because they're already rich enough to afford to go, or because they know they'll be able to leverage the experience in their consulting gigs to make more money later.<BR/><BR/>There is a new continuum, one in which mastering multiple specialities is the critical first step to being able to integrate those specialities. Make Lisp work in a secure, auditable environment. Give it a nice GUI builder. Make it so even a CTO's nephew can pick it up and learn it. Call it L#.NET and get it into the hands of half a billion programmers.<BR/><BR/>Leaving the existing continuum: That's "up" from Lisp.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166303880000#c116630391158280931" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02574521937449887649" rel="nofollow">Chalain</a> : 4:18 PM</div>

								<span class="item-control blog-admin pid-1334674507"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116630391158280931" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116630771537888627"></a> 				Oh, no, I would not say Cells (the dataflow hack) /is/ Common Lisp. I would call it... a dataflow hack, and merely brag about its transparency and Lispy-ness and integration with CLOS. Indeed, the lesson I learned from Cells is precisely not to achieve productivity by creating new languages, rather by creating powerful extensions to existing languages.<BR/><BR/>ken tilton<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166307660000#c116630771537888627" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 5:21 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116630771537888627" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116631613677914310"></a> 				Just because you can reprogram LISP (macros) in itself doesn't mean that LISP is the top dog.<BR/><BR/>Let me rephrase this. LISP, as in the language I can download and work with (say, Common Lisp, or Scheme, or some such), is certainly not top dog. In fact it's not much different from many other languages I could name.<BR/><BR/>LISP, as in, the idea that a self-referential language that can be extended 'holistically' - in a way that the syntax itself gets an upgrade, is, obviously, by definition, the dog's bollocks. You can do, in theory, anything with it.<BR/><BR/>However, I contend that ALL LANGUAGES FUNDAMENTALLY WORK THIS WAY - because computers work this way.<BR/><BR/>That is, everything a computer can possibly do, can be programmed. Assuming your language offers the raw basics (e.g. turing completeness), you can construct anything you like. You can make a new extension to java which looks a lot like java but adds some minor tidbit and still compiles to .class.<BR/><BR/>The only reason that language is no longer java is because the exhaustive JLS specs say so. The notion that LISP 'the concept' (in the sense that there's no one language that is the one and only lisp) disallows such a thing doesn't exist, but why would that matter?<BR/><BR/>Any sufficiently tricked out LISP is indistinguishable from a totally new programming language. This is also obvious. It's fun that you can call this 'LISP' and get away with this, but beyond a fun semantic little detail, who cares? If it quacks like a dove, walks like a bear, and looks like a postbox, it's not a duck, even if theoretically it still fits the definition of one, for all practical intents and purposes.<BR/><BR/>Let me try another rephase: Using some fancy preprocessor statements I have seen pascal code compiled with plain gcc. Throw in a bunch of libraries and you can fake anything. Is this a good thing? Does this mean any language that chooses to abolish the preprocessor because it turns all code into slag that cannot be reasoned about and is a pain in the tusch to use is somehow 'inferior'? Is C (with preprocessor) equal to LISP in that you can theoretically 'macro' every trick you can possibly think of? Is PASCAL really a dialect of C because of this?<BR/><BR/>In a certain very specific sense, yes, to all those questions. But I don't give a rat's ass about that 'sense'. It's entirely in the domain of the theoretic. In theory, practice is just like the theory, but in practice, practice is nothing like the theory. Or so the theory goes.<BR/><BR/>Final point: These vague discussions are imo pointless. The real question is some sort of combination of productivity, support, capability, execution speed, 'fun of programming', maintainability, etc, etc, along a large continuum of project sizes, types, and situations.<BR/><BR/>The idea that you can trick out your own language is but a teensy tiny little blip on the radar, and in many cases is actually a bad thing (ANY java code can be sort of understood by anyone who purports to know about java, at least in the basic sense. This has caused some dumbing down of the language but on the flipside random LISP code may be totally and utterly non sequitur - not even offering the slightest hint. That's the flipside of a supposed all-powerful language). What's worth more? The macro facilities or the provably linear-time chasability of code identifiers and the like?<BR/><BR/>I do not know the answer to that last question. All I know is: I have never read a satisfactory answer to the dilemma, merely a boatload of silent assumptions that the expressive power must be better... somehow.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166316120000#c116631613677914310" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://www.zwitserloot.com/" rel="nofollow">Reinier Zwitserloot</a> : 7:42 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116631613677914310" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116633270230125096"></a> 				Reinier, your experience programming Lisp macros and C macros is much different than mine. I actually did not recognize either language from your description. Ken Tilton<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166332680000#c116633270230125096" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 12:18 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116633270230125096" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116638432542471956"></a> 				If everything <I>can</I> be added to LISP, then it is just as fair to say that LISP has <I>none</I> of the features as to say that LISP has <I>all</I> of the features.<BR/><BR/>In other words: I would expect a language to give me guidance, useful idioms, ways to express what I want to say, and not just grammar. The power of a language, for me, is not to <I>allow</I> me to say things, but to <I>help</I> me say things succinctly, so I'll be understood. Language is a social thing, not something you make up on your own.<BR/><BR/>Others may feel differently: Creating your own language and your own conceptual world certainly gives you a feeling of power. But does that make for a powerful language? What power: Power over bytes, the power to solve problems, power in the marketplace, or power over people?<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166384280000#c116638432542471956" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://www.wuenschenswert.net" rel="nofollow">axel</a> : 2:38 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116638432542471956" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116639096146249083"></a> 				Ken Tilton: You hit the nail on the head.<BR/><BR/>IN THEORY you can make gcc do anything provided you have a library and you have a sack of preprocessor statements. Yes, even LISP, and thus, by extension, anything LISP can theoretically do.<BR/><BR/>IN THEORY only though - because as you said, in practice, #define is nothing like a LISP macro.<BR/><BR/>IN THEORY. This is my entire beef with the view that lisp is more powerful. I'm sure you can conjure up a theory that says: You can pull off stunt 'X' in LISP and you "can't" in Blub, and so LISP wins! - But that's not really true. It might be inconvenient in Blub, but you can coax Blub to do anything - this is the nature of computers and a side-effect of what we know as 'Turing completeness'.<BR/><BR/>Which means the real discussion is unfortunately much, MUCH more vague. As I said, it's a combination of convenience, expressiveness, maintainability, support, 'fun factor', and a bunch of other hard to peg aspects.<BR/><BR/>Does LISP win at THOSE? I don't think so at all. I can see Haskell taking the cake there for a certain type of brain.<BR/><BR/>Of course you can fake haskell in LISP with enough macros.... you see where this is going.<BR/><BR/>The notion of *easy* 'macroability' is just one amongst a large pool of things a programming language can have. The fact that it allows you to do it all is NOT the end of the discussion. In fact, there are tons of situations where I'd rather have a language with some restrictions to it. (note the *easy* - any language can be used or modified to support a feature that has all the benefits of macroability. Whether or not this is easy, common, or part of the language's "geist" is another issue entirely).<BR/><BR/>restrictions breed different types of power.<BR/><BR/>And that discussion, as I'm sure you've noticed by now, given the proclivity of the internet as a forum for this discussion over the past couple of decades, is a rather difficult one to settle. It's the old adage about Assholes and Opinions. Everything has at least one of both.<BR/><BR/>I'm not quite sure what it takes to make headway in the discussion, but throwing theoretics into it won't get you anywhere, I know that much for certain.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166390940000#c116639096146249083" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://www.zwitserloot.com/" rel="nofollow">Reinier Zwitserloot</a> : 4:29 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116639096146249083" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116652372409520345"></a> 				It seems to me that few, if any, participating in the language debate care to enumerate the idioms (aka aspects) that make one language "better" then another.<BR/><BR/>I really want to see a statement of a problem, and an example of how having that aspect is better suited to solving that problem.  I do not expect full working code, just snippets and structure to show the major semantic differences.   The Computer Language Shootout (http://shootout.alioth.debian.org/) is useless because some language aspects do not reveal themselves on such simple problems.  Furthermore, CLS has a high numerical processing bias; which probably does not match your problem domain.  If anyone knows of a site that does enumerate language idioms/aspects, please let me know.<BR/><BR/>CL, with it's macros, is one of the few languages that has demoted language semantics, idioms, or aspects to that of a code library. With this is mind, all languages are really compared based on your needs, and what libraries are available to solve those needs.  It is easy to see why some consider Java a win over CL: Java has libraries that solve the bulk of the problems at hand.  Dealing with new databases, file formats, protocols, thread pooling problems, transactional processing problems, even most numerical processing problems, all are solve by a Java library out there.  My Java programs are mostly just a scaffolding to hold others' work together.  <BR/><BR/>But I do miss macros.  Instead, I have to live with Java Reflection API and my own heavyweight compiler/decompiler to achieve my ends.  It is all behind a simple API, so although it is no CL, it is nowhere near the alternative: manual code expansion.<BR/><BR/>Here are some improvements I would like to see in CL:<BR/><BR/>Type Checked Macro Expansion: CL macros are simply s-expression concatenation with no type checking to prevent bone-head errors.  I just saw ?Emacs? has a macro expander debugger, but it is a runtime tool.  There are still many type checks that can be done at compile-time to verify macro sanity; albeit it requires more type declarations (or type analysis) to do these checks.<BR/><BR/>Better Compiler Optimizer: Macro's are good, but the high level code that leverages them is excruciatingly slow.  More work needs to be put into optimizers so that high level languages, built from macros, are fast enough for production use.<BR/><BR/>Separation of Concerns: Macro's are good, but they are as limited as libraries in that they declare only one of many possible implementations.  It would be good to separate the semantic effects of a macro from it's implementation so that experts can improve implementation without dealing with semantics.  Truly, I do not even know if this is possible, if not a compiler.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1166523720000#c116652372409520345" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02133319642949767284" rel="nofollow">Kyle Lahnakoski</a> : 5:22 AM</div>

								<span class="item-control blog-admin pid-1154277835"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116652372409520345" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116904519561863746"></a> 				You can't do continuations in Common Lisp without rewriting the reader, but you can do them in Haskell with a monad.<BR/><BR/>I'm still not sure what they're good for, though. And nice as Haskell is, there are things you can do efficiently in imperative languages that generally take a penalty in functional ones. So...<BR/><BR/>I'll argue that no language is best, but assembly is good for writing the first compiler in ;)<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1169045160000#c116904519561863746" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 9:46 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116904519561863746" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="117148512129119674"></a> 				Problem is that we was going backward for a long time.<BR/><BR/>Next thing we will reinvent is a <A HREF="http://en.wikipedia.org/wiki/Reflection_%28computer_science%29" REL="nofollow">reflection</A>. Yep, Lisp always had it. But who use it today?<BR/><BR/>Only SmallTalkers, i think. And LAMP'ers.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182538020000#c117148512129119674" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/06676314842171772808" rel="nofollow">Ivan Tihonov</a> : 2:47 PM</div>

								<span class="item-control blog-admin pid-2067369459"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=117148512129119674" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="754642796380190039"></a> 				Two suggestions:<BR/><BR/>Alan Kay's new <A HREF="http://www.peerbox.com:8668/space/Albert" REL="nofollow">Albert</A> project.<BR/><BR/><A HREF="" REL="nofollow">Frames/Contexts</A> combined with a declarative Prolog-like language.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182539580000#c754642796380190039" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://www.peerbox.com:8668/space/start" rel="nofollow">Kevin Greer</a> : 3:13 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=754642796380190039" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8207168349721572431"></a> 				I object to the assumption that Lisp is the most powerful widely-known language.<BR/><BR/>Besides the fact that the vast majority of Lisp's features are trivial to implement in other programming lagnauges, Lisp itself is highly restricted in its capabilities.<BR/><BR/>Lisp doesn't give you the power to access the underlying operating system like C. Nor does it give you the abiltity to leverage advanced hardware capabilities like moving calculations to graphics cards. From what I have read, most Lisp implementations don't even handle multiple threads well.<BR/><BR/>Lisp has some neat tricks, but they are all confined into a little box. As soon as you want to reach out and do something besides manipulate in-process data, its true weakness shows.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182545760000#c8207168349721572431" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/16213908463228592960" rel="nofollow">Jonathan</a> : 4:56 PM</div>

								<span class="item-control blog-admin pid-507787132"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8207168349721572431" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4370343066826414638"></a> 				; LISP has survived for 21 years because it is an approximate local optimum in the space of programming languages.<BR/>            ; -- John McCarthy (1980)<BR/><BR/>For me this quote describes the best what makes Lisp close to the last word.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182548280000#c4370343066826414638" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/18419863392058834783" rel="nofollow">DiG</a> : 5:38 PM</div>

								<span class="item-control blog-admin pid-1080829676"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4370343066826414638" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6703389479678065237"></a> 				More domain specific languages and systems can beat out Lisp.<BR/><BR/>If you are doing data analysis: SAS<BR/><BR/>If you are doing mathematical analysis and visualizations: Mathematica<BR/><BR/>But as a general purpose programming language, Lisp is pretty near the top of the heap.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182558600000#c6703389479678065237" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 8:30 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6703389479678065237" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="206277541311187166"></a> 				<I>Lisp doesn't give you the power to access the underlying operating system like C.</I><BR/><BR/>Nothing stops any language from producing machine code at runtime.<BR/><BR/>For thouse how do not understand what i am talking about there is a <A HREF="http://cl-cookbook.sourceforge.net/ffi.html" REL="nofollow">FFI</A>.<BR/><BR/>But wait... <A HREF="http://common-lisp.net/project/movitz/movitz.html" REL="nofollow">OS</A> in common lisp??? :)<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182573540000#c206277541311187166" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/06676314842171772808" rel="nofollow">Ivan Tihonov</a> : 12:39 AM</div>

								<span class="item-control blog-admin pid-2067369459"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=206277541311187166" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="5009955254903565702"></a> 				<I>Nothing stops any language from producing machine code at runtime.</I><BR/><BR/>Then nothing stops you from doing anything in another language that you can do in LISP.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182576180000#c5009955254903565702" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/16213908463228592960" rel="nofollow">Jonathan</a> : 1:23 AM</div>

								<span class="item-control blog-admin pid-507787132"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=5009955254903565702" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7578248668039679366"></a> 				<I>Then nothing stops you from doing anything in another language that you can do in LISP.</I><BR/><BR/>Sure, everything could be done in turing-complete language.<BR/><BR/>Feature of Lisp is that it allows you to built language you need easily.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1182587400000#c7578248668039679366" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/06676314842171772808" rel="nofollow">Ivan Tihonov</a> : 4:30 AM</div>

								<span class="item-control blog-admin pid-2067369459"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7578248668039679366" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="5165551991279431071"></a> 				> You can't do continuations in Common Lisp without rewriting the reader, but you can do them in Haskell with a monad.<BR/><BR/>Continuations don't require syntax in lisp, so it's incorrect to say that one can't do continuations in Common Lisp without rewriting the reader.<BR/><BR/>Efficient continutations do require some implementation support that isn't required by the Common Lisp standard, but that's a separate issue, as there are other lisps.  Many of the ones that have good support for continuations are known as "schemes".<BR/><BR/>Note that one can read scheme with a Common Lisp reader.  One can even write "Common Lisp" that uses the relevant operations; it's just that those operations won't necessarily work as well as one might like.<BR/><BR/>It's wrong to say that continuations require rewriting the reader.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1183069320000#c5165551991279431071" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/14592139915809999627" rel="nofollow">Andy Freeman</a> : 6:22 PM</div>

								<span class="item-control blog-admin pid-8684590"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=5165551991279431071" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3598705960058597957"></a> 				"Learning Lisp is like climbing Mount Everest...."<BR/><BR/>Great analogy!<BR/>Cited in <A HREF="http://gistout.com/" REL="nofollow">analogies and metaphors</A>.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2006/12/lisp-is-not-last-word.html?showComment=1191566460000#c3598705960058597957" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/03843566936926098528" rel="nofollow">GistOut</a> : 2:41 AM</div>

								<span class="item-control blog-admin pid-1477334592"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3598705960058597957" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
						
					  
					<br /> <p id="postfeeds"></p> <br />
					

					<br /> <br />
					<a href="http://weblog.raganwald.com/welcome.html">&lt;&lt; Home</a>
				</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic Technical Writing</a> / <a href ="http://raganwald.posterous.com">raganwald.posterous.com</a><br>
			<br>
			<div class="SideBarTitle">
				Books
			</div><a href="http://leanpub.com/shippingsoftware" title="A quarter-century of experience shipping software, distilled into fixnum bittersweet essays">What I&lsquo;ve Learned From Failure</a> / <a href="http://leanpub.com/combinators" title="Raganwald's collected adventures in Combinatory Logic and Ruby Meta-Programming">Kestrels, Quirky Birds, and Hopeless Egocentricity</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://weblog.raganwald.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://weblog.raganwald.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://weblog.raganwald.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://weblog.raganwald.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://weblog.raganwald.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://weblog.raganwald.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://weblog.raganwald.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://weblog.raganwald.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://weblog.raganwald.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://weblog.raganwald.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://weblog.raganwald.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://weblog.raganwald.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



		<div class="SideBarTitle">Management</div>

		<a href="http://weblog.raganwald.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://weblog.raganwald.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://weblog.raganwald.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://weblog.raganwald.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://weblog.raganwald.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://weblog.raganwald.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://weblog.raganwald.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://weblog.raganwald.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://weblog.raganwald.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://weblog.raganwald.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://weblog.raganwald.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://weblog.raganwald.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://weblog.raganwald.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://weblog.raganwald.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://weblog.raganwald.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://weblog.raganwald.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://weblog.raganwald.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://weblog.raganwald.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://weblog.raganwald.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://weblog.raganwald.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://weblog.raganwald.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_07_01_archive.html">07/08</a> /
		
		
		<br/></p>
		<br/>

		

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>