<html> 
<head>
        
        <title>My Mixed Feelings about Ruby</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />



	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

	<div id="leftcontent">
			<a href="http://raganwald.com/"><img src="/assets/media/raganwald_2008_350_150.png" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/></a><br/>(<i>This is a snapshot of my old weblog. New posts and selected republished essays can be found at <a href="http://raganwald.com"><strong>raganwald.com</strong></a></i>.)<br/><br/>
			
				<div class="DateHeader">Monday, June 30, 2008</div>
			

			<div class="Post"><a name="3851212997327201496">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html" title="permanent link">My Mixed Feelings about Ruby</a></span>
					<div style="clear:both;"></div><br/><br/><blockquote>There&#8217;s a lot of features of Ruby that I like, but there are some that just drive me nuts like blocks not taking blocks and the ampersand operator. Raganwald did a great job of explaining blocks, procs, and the ampersand in this blog post: <a href="http://weblog.raganwald.com/2008/06/what-does-do-when-used-as-unary.html">Explanation of Ruby&#8217;s Unary operator</a>. I came away with the feeling, &#8220;Wow! It took that much explanation just to tell how to send blocks around?&#8221; If blocks were first-class citizens, Ruby would be more elegant. Raganwald would not be writing huge blog posts on block vs. proc because it would be unneeded.</blockquote>
<div>&mdash;Blaine Buxton, <a href="http://blog.blainebuxton.com/2008/06/too-complex.html">Too Complex?</a></div>
<br />
I feel for Blaine, I really do. When I first looked at Ruby, quite honestly I hated it. Not hated it in a Blubb-dacious &ldquo;It&rsquo;s not the same as my popular language&rdquo; way, but hated it in a &ldquo;The language is full of Accidental Complexity&rdquo; way.<br />
<br />
To my eyes, Ruby as a language looked a lot like an internal IT app that is built as an aggregation of features. There might be a wonderful, coherent design in the implementation that I can&rsquo;t see, but the interface I use seems like a bunch on one-off features that don&rsquo;t play well together.<br />
<br />
Ruby definitely isn&rsquo;t <a href="http://www.cincomsmalltalk.com/userblogs/avi/blogView?showComments=true&entry=3284695382">turtles all the way down</a>. And I have never stopped being troubled by this. I lamented the fact that <a title="The significance of the meta-circular interpreter" href="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html">Ruby isn&rsquo;t written in Ruby</a>. <a title="Why Rubinius Matters to Ruby's Future" href="http://weblog.raganwald.com/2007/12/why-rubinius-matters-to-rubys-future.html">Twice</a>. No, make that <a title=" Turtles all the way down, please" href="http://weblog.raganwald.com/2008/02/turtles-all-way-down-please.html">three times</a>.<br />
<br />
Deep breath. But.<br />
<br />
There&rsquo;s a part of my personality that craves purity and regularity in a system. Purity and regularity have practical benefits, to be sure, but at the same time there are practical benefits to being messy and having special cases optimizing for things people do frequently. This is why design is freakin&rsquo; hard. It&rsquo;s not as easy as following a bunch of rules that produce a system with the smallest possible intellectual surface area, otherwise we&rsquo;d have stopped with Scheme and its five axiomatic special forms.<br />
<br />
<br />
<center><object width="425" height="344">
<param name="movie" value="http://www.youtube.com/v/1kvdq8cRNBM&hl=en"></param>
<embed src="http://www.youtube.com/v/1kvdq8cRNBM&hl=en" type="application/x-shockwave-flash" width="425" height="344"></embed></object><br />
<br />
<em>A Rube Goldberg contraption does a simple thing (like making ramen) in an extremely complex way. It turns accidental complexity and irregularity into entertainment.</em></center><br />
Nor is it as easy as piling more features on regardless of how well they fit or whether people will actually use them. Otherwise Windows would have 97% of the market and OS X 3%. (<em>Oh wait</em>.)<br />
<br />
When it comes to design, sometimes you have to experience the result to judge it. You can decide whether a chair is attractive by looking at it, but you really need to sit in it a while to know whether you will feel comfortable using it. Even then, only long experience will tell you whether it is a keeper. Many things that are nice in the showroom are mediocre in day-to-day use.<br />
<br />
Design is all about problem solving. What problem do you think programming languages solve as a group? What problem does Lisp solve? Smalltalk? Ruby? For whom?<br />
<br />
Matz has said that Ruby is an attempt to solve the problem of making programmers happy. So maybe we aren&rsquo;t happy with some of the accidental complexity. But can we be happy overall? Can we find a way to program in harmony with Ruby rather than trying to <a href="http://en.wikipedia.org/wiki/Greenspun's_Tenth_Rule">Greenspun</a> it into Lisp?<br />
<br />
(I speak as a man working on rewriting code for Ruby: By far the hardest part of this is trying to provide the power of macros in a mechanism that works in harmony with the Ruby Way, rather than bolting Lisp onto Ruby&rsquo;s side.)<br />
<br />
Programming languages also solve the deep problem of helping programmers think about the parts of a program that matter and not clutter their minds up with the parts that don&rsquo;t matter. This is a very hard problem. Very, very hard. Make things too simple, have too few axioms and abstractions, and you end up with something where each element is extremely simple to understand, but any non-trivial program has too many elements with difficult-to-understand interactions and dependencies so as a whole programs are harder to understand.<br />
<br />
Does a regular language help us understand the parts of programs that matter more than an irregular language? That is not an easy question to answer. When I&rsquo;m struggling with some subtle difference between Proc.new and lambda, I want to shout YES, GODDAMIT, GIVE ME SOME CONSISTENCY.<br />
<br />
I&rsquo;m wary of trying to decide about languages based on infrequent edge cases. With a certain very popular language, I&rsquo;ve made up my mind that the design choices don&rsquo;t pay off, that the places where you work hard to express yourself aren&rsquo;t places where the easy, obvious thing is easy to write and obvious to read. But so far in Ruby, the things that trouble me do seem to have some inherent trade-off merit. I can see how making blocks a special case makes certain eay, simple things easy. So is it overall the best possible design? I don&rsquo;t know. is it a good design? So far it seems to be a reasonable design.<br />
<br />
At my core, I believe axiomatically that there is no one &ldquo;best&rdquo; language. That is not an excuse for saying that every language has merit. While I think that there can be more than one good language with different approaches and styles, I do not exclude the possibility that 90% of the programming languages in existence are stinkers through and through.<br />
<br />
Is Ruby better for me personally than Lisp or Smalltalk? I don&rsquo;t know the answer to that question either.<br />
<br />
I decided a while back that I would <a title="I'm not young enough to know everything" href="http://weblog.raganwald.com/2005/10/im-not-young-enough-to-know-everything.html">give Ruby an honest try</a>. And while I give myself the freedom to express my misgivings about some of the choices Matz has made, I also try to keep an open mind about them.<br />
<br />
It&rsquo;s really freakin&rsquo; (I know, I used this word already) hard for me to to do, but I&rsquo;m trying to find out if <a href="http://www.dreamsongs.com/WorseIsBetter.html">worse might be better</a>. And I don&rsquo;t mean, &ldquo;Ruby is worse than Lisp, but it&rsquo;s better for those n00bs over there.&rdquo; That&rsquo;s not embracing change. I mean I am trying to discover if worse might be better for me personally, and it is hard for me to open my mind to that possibility when I&rsquo;m already invested in &ldquo;better.&rdquo;<br />
<br />
At this moment in time I have extremely mixed feelings about Ruby. I sorely miss the elegance and purity of languages like Scheme and Smalltalk. But at the same time, I am trying to keep my mind open to some of the ways in which Ruby is a great programming language.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html" title="permanent link">10:42 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			
			    <div class="blogComments">
                                
                                <a name="comments"></a><strong>Comments on &ldquo;<em>My Mixed Feelings about Ruby</em>&rdquo;</strong>:<br/>
						
							<div class="blogComment">
								<a name="5946513087999120712"></a> 				"Matz has said that Ruby is an attempt to solve the problem of making programmers happy."<BR/><BR/>I think he has succeeded. Let's be honest, ruby as a language is more COMPLEX than php.<BR/><BR/>At the same time, as a language - and its whole design - ruby is a LOT better than php.<BR/><BR/>Coding in ruby is fun. I think a few things could be improved, but I am happy with ruby since 5 years by now.<BR/><BR/>If i compare ruby to other languages, I feel repulsed. The syntax of other languages is mostly horrible. Some languages have an ok syntax (haskell) but are A LOT MORE complex than ruby (!)<BR/><BR/>Perl is an utter mess. <BR/><BR/>Python is ok. I dont like some decisions, but python is a good language - dont get me wrong here. I hope ruby and python join forces because they have A LOT in common, much more than i.e. python and java or ruby and java (ever will).<BR/><BR/><BR/>I agree about complexity in one point - it takes a lot of time to "master" ruby. I think, personally, that ruby is a bit too complex. I know that if i would make a new language, I would do away with module vs object vs class and make prototype objects only, including "behaviour" objects where one just "steals" behaviour to get the functionality one wants.<BR/><BR/>Ruby helped me become a better programmer, by enabling ME to think better. I was a horrible PHP programmer, i still am. But I wrote my IRC bot in ruby, and it worked (it was buggy but it worked).<BR/><BR/>I never was able to do the same in php, and this was 4 years ago.<BR/><BR/><BR/>'At my core, I believe axiomatically that there is no one “best” language.'<BR/>I disagree. For me what matters most is syntax. I love that you can omit the () in ruby. People complain about this but I think they dont get the point - it makes the overall code more beautiful to read.<BR/><BR/>If you dont care what you wrote then maybe stick to perl, but I want to build a whole infrastructure in ruby, and thus I do care about the beauty of code.<BR/><BR/><BR/>'I sorely miss the elegance and purity of languages like Scheme and Smalltalk. But at the same time, I am trying to keep my mind open to some of the ways in which Ruby is a great programming language.'<BR/><BR/>Maybe we come from different areas. I always liked scripting languages (yes, that includes perl!)<BR/><BR/>I never liked C or C++ much. And I had no real use for either Scheme or Smalltalk although Smalltalk is very close to ruby in regards to thinking WITH objects (i didnt like scheme syntax)<BR/><BR/>At the end of the day I think what ruby really will become is the language that will replace perl. And this alone is a big task, for perl still has a lot of old users.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214844840000#c5946513087999120712" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/09636171104216432368" rel="nofollow">Markus</a> : 12:54 PM</div>

								<span class="item-control blog-admin pid-111220478"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=5946513087999120712" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="624468098427003984"></a> 				Some things become edge cases because we don't use them often.  And some things we don't use often because they're inconvenient.  I think there's more potential to blocks, but some patterns were relegated to edge case because of their inconvenience.<BR/><BR/><BR/>I also feel like Ruby is this clobbered-together solution. Maybe because it is.<BR/><BR/>Would have been better if Ruby was perfectly designed from the start, instead of adding features that make people happy and productive, but don't always mesh perfectly together.<BR/><BR/>Unfortunately, in real life that doesn't happen, instead we get to choose from patchwork languages, languages that never change, and languages that change in consistent, but inconvenient, ways.<BR/><BR/>The last two options worked very well for Scheme and Java, but sometimes it's not about how elegant your shoes are, but how comfortably you can walk in them.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214845920000#c624468098427003984" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon openid-comment-icon"><img src="http://www.blogger.com/img/openid16-rounded.gif" alt="OpenID" style="display:inline;" /></span>&nbsp;<a href="http://assaf.labnotes.org/" rel="nofollow">Assaf</a> : 1:12 PM</div>

								<span class="item-control blog-admin pid-1967910208"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=624468098427003984" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4857504600371814117"></a> 				I'm still learning Ruby and Rails, and its helping become a better programmer in general. I'm a .Net programmer, and I think its the best thing MS has produced. It's not perfect and leaves a lot to be desired. Monorail is part of the answer to .Net's problems, but there is no perfect solution.<BR/><BR/>Ruby and Rails are the same. Rails has helped my learn MVC and I'm learning REST now. I see the wisdom in convention over configuration, and why being simple is much better than being elegant. However, this is an area of trouble with Ruby. It can be very elegant to the point where its not clear to a non-rubyist like me what the code is doing.<BR/><BR/>When a language/platform gives you the ability to be more productive, its a very good thing. There are always trade offs to consider. In Ruby/Rails, its the complexity and performance concerns.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214847540000#c4857504600371814117" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13011633285693798889" rel="nofollow">josh</a> : 1:39 PM</div>

								<span class="item-control blog-admin pid-637169249"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4857504600371814117" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3550726759301648690"></a> 				Great post.<BR/><BR/>One question:  Wouldn't Greenspun be the past tense of Greenspin?<BR/><BR/>As in, "Stop trying to Greenspin that DSL; it doesn't *need*  macros!"<BR/><BR/>:)<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214855460000#c3550726759301648690" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/14121816809671217162" rel="nofollow">James Britt</a> : 3:51 PM</div>

								<span class="item-control blog-admin pid-1907184072"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3550726759301648690" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2070514467923630036"></a> 				Let's reverse the argument but keep the pragmatic viewpoint: why keep the rough edges when you can slowly smooth them out of the design? For example the proc vs. blocks vs. lambdas vs. ampersand symbols is a necessary piece of cruft (i.e. do people use them in different incompatible ways)? If all the uses could be made compatible why no slowly moving the design in this direction. Another example, turtles all the way down is important, that's why we have a couple of candidates in this direction today, the community/market has spoken, so it's fine to slowly go in this direction.<BR/><BR/>It doesn't need to be a either/or dichotomy, we can have cruft in phase 1 and design in phase X, every phase in between is a movement to a simpler solution. If you start with careful design you'll be constrained by your own knowledge (as good design is based on constraints) and the less you know about languages the worse are going to be the constraints. It's much better to have no constraints but evolve (evolution is key) than choose the wrong constraints. So Ruby becomes better because the community complains about its warts and shapes the direction of future features.<BR/><BR/>Actually this dichotomy between design and evolution is very important, because you can have a design that works better than evolution, but if and only if you are really really smart and knowledgeable. It's easier to succeed with evolution, but if you try to control this process the results aren't good. Evolution of a language means killing cruft that hurts (even if killing it hurts) and adding cruft that is good. It also means not falling in the with the language as it is, instead loving it because of what it can become (always looking forward).<BR/><BR/>Going to the simple vs. complex dilemma, it's easy to pat yourself in the back and say "look how simpler than Blub we are", but this will only make you better than Blub. It's also easy to look at some artificial standard (let's say Scheme, Smalltalk or Haskell (btw all languages that I love)) and complain that our language is broken because it's more complex. It doesn't matter how complex or simple it is today if the language can evolve towards simplicity (or any other artificial standard).<BR/><BR/>Ruby's future seems uncertain to me: now we have multiple implementations, so it's possible to have different features emerging in different implementations and evolve the language, but this evolution is a dead end if the features can't be easily shared between implementations. Lisp, Scheme, Smalltalk, all suffered from multiple (slightly incompatible) implementations, Ruby can go in this direction too if we aren't careful. OTOH if it successfully manage to let the implementations share good features and deprecate irrelevant ones than Ruby has a good chance of becoming something unheard of: a language with multiple implementations that doesn't hurt the developers.<BR/><BR/>P.S. People forget that <A HREF="http://www.laputan.org/mud/mud.html" REL="nofollow">Big Ball of Mud</A> is also an architecture. Perl and Ruby have a great design behind it, it's not because it looks like a big ball of mud that is a less effective design than an "elegant" design.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214856240000#c2070514467923630036" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/12528969103424062002" rel="nofollow">Daniel Yokomizo</a> : 4:04 PM</div>

								<span class="item-control blog-admin pid-575011157"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2070514467923630036" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6153259045575186915"></a> 				This is somehow relevant to an <A HREF="http://talklikeaduck.denhaven2.com/articles/2008/05/21/what-would-you-miss-if-you-had-to-stop-using-ruby-and-go-back-to-smalltalk" REL="nofollow">an article I wrote about a month ago</A> on my experience/liking of Ruby based on long-time Smalltalk experience.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214857200000#c6153259045575186915" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/09674635730835669212" rel="nofollow">Rick DeNatale</a> : 4:20 PM</div>

								<span class="item-control blog-admin pid-1792249924"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6153259045575186915" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6841382830753168969"></a> 				All the following is just a flame, but I had to say it :)<BR/><BR/>I have also gave ruby a try and enjoyed it a lot by then. But as I understood later this was due my love to javascript, which is a far greater language. <BR/><BR/>And here is why:<BR/>C# added LINQ, Javascript doesn't need them because it has compact enough syntax already. Java now have closures, Javascript has them too. In python everything is an object, in javascript this is also true. In ruby you can create object attributes dynamicaly, the same goes to javascript.<BR/>On the other side javascript have a very small syntax overhead, what can't be told about C# and even more ruby. It beats on the other hand it comes head to head with ruby expresiveness when needed, what nor python neither C# (vell now it can).<BR/>The only problem is that it's slow, but we will see who will be the king pretty soon. <BR/><BR/>Now hear the final part. The best language will appear in few years few years, when every language will be ported to .NET/Java CLR. You just wait...<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214859540000#c6841382830753168969" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/14812446586343348809" rel="nofollow">Sergej Andrejev</a> : 4:59 PM</div>

								<span class="item-control blog-admin pid-261510978"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6841382830753168969" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7130032343245657540"></a> 				Reg, <BR/>I know you allude to this in the sentence "Purity and regularity have practical benefits", but I place more emphasis on them (or you de-emphasize them to make a point this essay). <BR/><BR/>As I'm sure you're aware, purity and regularity have a huge benefit in terms of making the code understandable. <BR/><BR/>In your post on news.yc (http://news.ycombinator.com/item?id=232246), you give an excellent example of some confusing ruby code:<BR/><BR/>"Just for a chuckle, what does this snippet of code do?<BR/><BR/>  p = Proc.new { return :to_sender };  <BR/>  p.call<BR/><BR/>What about this one?<BR/><BR/>  l = lambda { return :to_sender };  <BR/>  l.call<BR/><BR/>Why and how do they differ? And given that they differ in behaviour, what do you think this should return? False, right?<BR/><BR/>  c.class == l.class<BR/>"<BR/><BR/>For me, I have better things to occupy my neurons with than the difference between lambda {} and proc {} and Proc.new(). <BR/><BR/>I can keep an open mind about design decisions, up to the point where the accidentally complexity becomes a burden. <BR/><BR/>These days, I don't have to care about lambda{} vs proc{}. All I have to remember is (fn []). I've been playing with Clojure (http://clojure.org/), and I'm really loving it, as a clean, full-featured, fast lisp that runs on the JVM.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214861940000#c7130032343245657540" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/14551766042595741221" rel="nofollow">Allen Rohner</a> : 5:39 PM</div>

								<span class="item-control blog-admin pid-1022259691"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7130032343245657540" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="176599615228088206"></a> 				"otherwise we’d have stopped with Scheme"<BR/><BR/>Given that other languages cannot do what Scheme can do and are not as elegant as Scheme, perhaps we should have stopped with Scheme and worked on making it better. Perhaps adding features like Erlang-like concurrency. Imagine where we would be today if Sun had championed Scheme instead of Java.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214881860000#c176599615228088206" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/03727890012987003572" rel="nofollow">Peter Michaux</a> : 11:11 PM</div>

								<span class="item-control blog-admin pid-868489207"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=176599615228088206" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8047136189656835353"></a> 				"perhaps we should have stopped with Scheme and worked on making it better... Imagine where we would be today if Sun had championed Scheme instead of Java."<BR/><BR/>Then we might end up with something like Clojure. I know my last post already plugged it, but seriously, check it out. It's a lisp, neither scheme nor CL, but closer in spirit to Scheme. It has lots of nice concurrency features, like immutable local variables, a parallelized map funcion, and Software Transaction Memory (think (begin transaction) (dostuff) (commit) rather than locking. Oh, and it runs on the JVM, so you have trivial access to any Java library and you can even use Java debuggers.<BR/><BR/>The author has said he isn't too interested in Erlang style messaging for in-process communication, but he's not opposed to the idea for cross-process communication.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214889300000#c8047136189656835353" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/14551766042595741221" rel="nofollow">Allen Rohner</a> : 1:15 AM</div>

								<span class="item-control blog-admin pid-1022259691"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8047136189656835353" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6146653901007396203"></a> 				All this talk about languages needs some clarification as to what they are and the problems they try to solve. It's not about making programmers happy, it is to <A HREF="http://shelter.nu/blog/2008/06/language-semantics-and-software.html" REL="nofollow">communicate well up and down the tree of development</A>.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214897100000#c6146653901007396203" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/10613480150660825848" rel="nofollow">Alexander Johannesen</a> : 3:25 AM</div>

								<span class="item-control blog-admin pid-375778144"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6146653901007396203" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4167019182222659755"></a> 				If it wasn't for Ruby I would never have rediscovered the power and elegance of Smalltalk.  Now I am a happy programmer.  <BR/><BR/>Thank you Ruby.  I will be eternally grateful.  :)<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214906580000#c4167019182222659755" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/17632405835088606624" rel="nofollow">Nick Smith</a> : 6:03 AM</div>

								<span class="item-control blog-admin pid-1635440829"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4167019182222659755" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1381141916936865234"></a> 				Alexander:<BR/><BR/>Programming languages must solve many problems to be successful. In theory they exist to communicate between people, and I agree with you that this is an important purpose.<BR/><BR/>However, &ldquo;In theory there is no difference between theory and practice, but in practice there is.&rdquo;<BR/><BR/>In practice languages need to market themselves by appealing to all sorts of feelings and emotional needs like greed, fear, belonging, and exclusivity. In practise languages often must represent evolutionary incremental change in order to foster adoption unless a cataclysmic extinction event (like the creation of a new platform that replaces an old platform) takes place.<BR/><BR/>Languages have many purposes and fulfill many needs. This does not mean that they do not have a primary purpose, of course, but it also does not mean that we can disregard all other purposes as inessential.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214922180000#c1381141916936865234" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 10:23 AM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1381141916936865234" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="5899722704171081656"></a> 				Hi Reg:<BR/><BR/>Ruby reflects the learning process of its creator.  Imagine the language he would create today in trying to achieve the same goal, but starting with a blank screen.<BR/><BR/>I was always irritated with all the closing parens when working in lisp, but I adored reader macros.<BR/><BR/>To the point of this intrusion: I read your post last night and this morning I read, The Most Important Idea in Computer Science, http://bc.tech.coop/blog/060224.html, which played such sweet point/counterpoint to your melody.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214928000000#c5899722704171081656" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13317638971542317743" rel="nofollow">Norbert</a> : 12:00 PM</div>

								<span class="item-control blog-admin pid-1685265156"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=5899722704171081656" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2667225588925539731"></a> 				Reginald: Of course they must do many things to be successful. But the current focus is on how to shift bits back and forth and which syntax is used for such, and not about the meaning of why the computer was invented in the first place. And our programming language abstractions were created to shift those bytes around to the convenience to programmers in order to their jobs easier. Through the years and expansion of the development stack, the two ends of the communication stack are farther apart, and the languages and tools in the middle seems to be less and less about conveying the original ideas.<BR/><BR/>This discussion is about Ruby, and for me, Ruby doesn't add much to how I shift bits around. The environment isn't that different, the syntax isn't that different, the OO paradigms aren't that different, the community isn't that different ... not different to other alternatives such as PHP, Python, Lua, Perl ... heck, I'll throw in Java, .Net and C++ in there as well. Erlang and Lisp stands out in syntax and the functional completeness, but hey, even XSLT does that. <BR/><BR/>The actual languages aside, the real crux of the matter lies in how people design APIs. That's where the semantics are, that's where we "interface", so to speak. And seriously, if the APIs were gold, I don't care if Ruby syntax is bronze. The point of trying out new languages to me is to see if they can help me communicate between the computer and humans better. If it doesn't do that, what is their point? Seriously?<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1214985900000#c2667225588925539731" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/10613480150660825848" rel="nofollow">Alexander Johannesen</a> : 4:05 AM</div>

								<span class="item-control blog-admin pid-375778144"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2667225588925539731" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6240717385856648974"></a> 				Alexander:<BR/><BR/>The trouble I am having with this discussion is that "readability" is all motherhood and apple pie, but when you get down to business there are many ways to skin a cat. (Sorry for the mixed metaphor, but it illustrates a point all by itself, which I will get to in a moment.)<BR/><BR/>Thus you get the phenomenon in the Java world where there is a huge debate over closures. Not a debate over how to add closures but whether to add them at all. Each side argues that they are trying to make Java programs readable!!!<BR/><BR/>One side argues they are adding closures to make it easier to communicate certain ideas. The other argues that closures make programs harder to read and that certain problems should be solved with the ideas that are already in the language.<BR/><BR/>Within Ruby, what's with metaprogramming? By your argument we can hand wave the namespace conflict issues away (labouring to produce correct programs not our problem), but does writing "acts_as_fubar" make a program more readable? How about "find_people_by_ssn"?<BR/><BR/>Many Rails aficionados say yes. Many people who dislike Rails scream that it makes programs impossible to understand: they cannot find any of the fubar-ish methods in a class definition, and method_missing magic is all mirrors and prestidigitation.<BR/><BR/>From this, I conclude that "designing a language to help people communicate with each other" sounds wonderful, and certainly it beats writing Brainfuck, but it is not obvious to me that we will all agree on whether the resulting language does the job or not.<BR/><BR/>In the end, I believe we need to concentrate on writing programs for people to understand. One might be tempted to say, "Aha! If writing a program for people to understand is important, the language we use must be designed directly with this in mind," but I am not so sure.<BR/><BR/>For example, if a language is so "productive" (whatever that means) that one person can replace a team of three, then perhaps a small YCombinator-style startup can work with one technical person and one business person.<BR/><BR/>Is readability still paramount? Obviously, eventually. But in the mean time, if they can build something and sell the company for $20 million, who cares?<BR/><BR/>Or perhaps productivity works another way. If a programmer is twice as productive, instead of producing twice as much code, perhaps she produces the same amount of code but now spends 50% of her time refactoring the code even after it works to be readable.<BR/><BR/>Given any reasonable programming language, I would lay my money down that someone who spends 50% of their time rewriting their code for readability will produce more readable code than someone who writes it once in a so-called readable language.<BR/><BR/>Finally, we return to Ruby. Matz said he designed it with giving Joy to programmers in mind. I will state directly that given two programmers of equal talent, if one enjoys their work and the other does not, the one who enjoys their work will produce better work by any measure you can articulate, including producing readable code.<BR/><BR/>Again we come down to this: readability is a property of programs, and the influence of a language on the readability of the programs is indirect. That does not mean the language doesn't matter, but it does make me suspicious of the argument that we can look at one language and say it produces readable programs and look at another language and say it does not.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1215001020000#c6240717385856648974" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 8:17 AM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6240717385856648974" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4153501616419938584"></a> 				Hi Reg:<BR/><BR/>I agree readability is a problematic word/concept and for me it is one of those horizon words, it appears to be there and no matter how hard you try, you never get to it.<BR/><BR/>You wrote: "Thus you get the phenomenon in the Java world where there is a huge debate over closures. Not a debate over how to add closures but whether to add them at all."<BR/><BR/>Are you arguing that there should be no discussion about the merits and impact of adding new functionality to something? Or that the discussion of merit should be secondary to the one about how to implement the addition? Or that in the case of Java discussions about readability are an oxymoron?<BR/><BR/>On the other side of the coin; for me reading is a human activity and try as I might, I could not find the reader in your discussion on readability.<BR/><BR/>Let me leave you with a quote I like from my friend <A HREF="http://www.analecta.com/" REL="nofollow">Mark Baker</A>:<BR/><BR/>Experience is normative; language is contingent.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1215016380000#c4153501616419938584" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13317638971542317743" rel="nofollow">Norbert</a> : 12:33 PM</div>

								<span class="item-control blog-admin pid-1685265156"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4153501616419938584" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2142979225149783001"></a> 				<I>You wrote: "Thus you get the phenomenon in the Java world where there is a huge debate over closures. Not a debate over how to add closures but whether to add them at all."<BR/><BR/>Are you arguing that there should be no discussion about the merits and impact of adding new functionality to something? Or that the discussion of merit should be secondary to the one about how to implement the addition? Or that in the case of Java discussions about readability are an oxymoron?</I><BR/><BR/>No, no, and most definitely no.<BR/><BR/>I am arguing that while it is easy to agree that languages ought to facilitate writing readable programs, it is not easy to derive any tangible heuristics for language design from this extremely motherhood and apple pie sentiment.<BR/><BR/>The example of Java folks arguing about whether to include closures suggests to me that we can take an idea this is fifty years old and reasonable, intelligent people can disagree over whether it will facilitate writing readable programs.<BR/><BR/>And so it goes for almost any language design feature. Pythonistas say that standardizing indentation make programs more readable. Detractors say that there is a trade-off, easily seen in that Python's lambdas are severely restricted because there is no easy way to parse a multi-line lambda. But supporters claim you can do almost anything with a named function. SO you can again have two reasonable, intelligent people who cannot agree about whether significant whitespace makes programs more or less readable.<BR/><BR/>So my suggestion here is that it's okay to debate language features, it's okay to debate implementations, and it is certainly possible to evolve Java to b more readable.<BR/><BR/>However, I do not think it is easy or even possible to design a language to produce more readable programs directly. I think that arises from people trying to write more readable programs, and supporting that effort. The distinction may seem subtle, but it is very real.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1215019680000#c2142979225149783001" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 1:28 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2142979225149783001" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2298862217708758287"></a> 				Reginald: I've tried to <A HREF="http://shelter.nu/blog/2008/07/round-and-round-it-goes.html" REL="nofollow">give it a better think and a summary over on my blog</A>. Sorry for taking time and writing so much about this, but this is a complex issue for me, one I feel rather strongly about. I don't think we disagree much actually, but perhaps slightly see past each other in the way to solve (in which I'd fight the language with swearing a lot, but you perhaps would accept and move on? :) it.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1215081540000#c2298862217708758287" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/10613480150660825848" rel="nofollow">Alexander Johannesen</a> : 6:39 AM</div>

								<span class="item-control blog-admin pid-375778144"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2298862217708758287" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1306935452959134222"></a> 				I sympathize with the desire for cleanliness and elegance found in, say, Scheme.<BR/><BR/>I have several years experience in Lisp, Scheme, and Ruby.  And it is a little known fact that Matz was a lisper at the time he wrote ruby.  He even contributed several packages to Emacs.<BR/><BR/>Here's an analogy.  Consider the design of the piano keyboard layout.  You might say it is "optimized" for diatonic C, while it's "ugly" or "inconsistent" for the other keys (besides than A minor, heh).<BR/><BR/>But piano players LIKE the resultant peculiarity --- the odd geography of the scale in non-C keys.  The scales have unique characters which are USEFUL and even LOVED.<BR/><BR/>The keyboard could have been designed in a "simple, elegant" manner by making all the keys uniform, thereby making transpositions trivial.  One has to wonder why this "obvious" design didn't take.<BR/><BR/>Another example is the "ugly" distance of a major 3rd between the G and B strings of a guitar, whereas all the other strings are separated by 4ths.<BR/><BR/>Yet people love the guitar, along with this quirky major 3rd which screws up the symmetry and "purity" of the instrument.  At the very least it's useful because it makes the top and bottom strings the same note, E.  It's a trade-off between practicality and the "platonic beauty" of a "mathematically consistent" instrument.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1217741760000#c1306935452959134222" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07390108711658127334" rel="nofollow">Itchy</a> : 1:36 AM</div>

								<span class="item-control blog-admin pid-879600689"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1306935452959134222" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8360576830928633122"></a> 				Re: Allen Rohner<BR/><BR/>In many years of ruby programming, I've hardly ever used the 'return' keyword, so I've never encountered the problem you mentioned.  Though I understand your concern, it's had no practical effects in my case.<BR/><BR/>Writing the variable or statement without the "return" keyword is sufficient.  If you plan to exit from a method prematurely, it is better to declare that you are doing so with try/catch.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1217742660000#c8360576830928633122" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07390108711658127334" rel="nofollow">Itchy</a> : 1:51 AM</div>

								<span class="item-control blog-admin pid-879600689"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8360576830928633122" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7166725860760912565"></a> 				<span class="deleted-comment">This post has been removed by the author.</span><br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1217769240000#c7166725860760912565" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07390108711658127334" rel="nofollow">Itchy</a> : 9:14 AM</div>

								<span class="item-control blog-admin "><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7166725860760912565" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1992848784153381087"></a> 				Ooops, I meant throw/catch instead of try/catch.<BR/><BR/>In ruby, throw/catch is a control structure.  The exception mechanism is raise/rescue.<br />
								<div class="byline"><a href="http://weblog.raganwald.com/2008/06/my-mixed-feelings-about-ruby.html?showComment=1217769360000#c1992848784153381087" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07390108711658127334" rel="nofollow">Itchy</a> : 9:16 AM</div>

								<span class="item-control blog-admin pid-879600689"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1992848784153381087" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
						
					  
					<br /> <p id="postfeeds"></p> <br />
					

					<br /> <br />
					<a href="http://weblog.raganwald.com/welcome.html">&lt;&lt; Home</a>
				</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic Technical Writing</a> / <a href ="http://raganwald.posterous.com">raganwald.posterous.com</a><br>
			<br>
			<div class="SideBarTitle">
				Books
			</div><a href="http://leanpub.com/shippingsoftware" title="A quarter-century of experience shipping software, distilled into fixnum bittersweet essays">What I&lsquo;ve Learned From Failure</a> / <a href="http://leanpub.com/combinators" title="Raganwald's collected adventures in Combinatory Logic and Ruby Meta-Programming">Kestrels, Quirky Birds, and Hopeless Egocentricity</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://weblog.raganwald.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://weblog.raganwald.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://weblog.raganwald.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://weblog.raganwald.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://weblog.raganwald.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://weblog.raganwald.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://weblog.raganwald.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://weblog.raganwald.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://weblog.raganwald.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://weblog.raganwald.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://weblog.raganwald.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://weblog.raganwald.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://weblog.raganwald.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://weblog.raganwald.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



		<div class="SideBarTitle">Management</div>

		<a href="http://weblog.raganwald.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://weblog.raganwald.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://weblog.raganwald.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://weblog.raganwald.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://weblog.raganwald.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://weblog.raganwald.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://weblog.raganwald.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://weblog.raganwald.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://weblog.raganwald.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://weblog.raganwald.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://weblog.raganwald.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://weblog.raganwald.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://weblog.raganwald.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://weblog.raganwald.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://weblog.raganwald.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://weblog.raganwald.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://weblog.raganwald.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://weblog.raganwald.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://weblog.raganwald.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://weblog.raganwald.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://weblog.raganwald.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://weblog.raganwald.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://weblog.raganwald.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://weblog.raganwald.com/archives/2008_07_01_archive.html">07/08</a> /
		
		
		<br/></p>
		<br/>

		

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>